;;(load source "helpers.qa2")
#fload "../lib/libs.sf"
#fload "helpers.sf"


(SECTION 6 3 1) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test #t
      '#t
      '#t)
(test #f
      '#f
      '#f)
(test '#f
      '#f
      '#f)

(test (not #t)
      '(not #t)
      '#f)
(test (not 3)
      '(not 3)
      '#f)
(test (not (list 3))
      '(not (list 3))
      '#f)
(test (not #f)
      '(not #f)
      '#t)
(test (not '())
      '(not '())
      '#f)
(test (not (list))
      '(not (list))
      '#f)
(test (not 'nil)
      '(not 'nil)
      '#f)

(test (boolean? #f)
      '(boolean? #f)
      '#t)
(test (boolean? 0)
      '(boolean? 0)
      '#f)
(test (boolean? '())
      '(boolean? '())
      '#f)

(SECTION 6 3 2) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test '(a . (b . (c . (d . (e . ())))))
      '(a . (b . (c . (d . (e . ())))))
      '(a b c d e))
(test '(a b c . d)
      '(a b c . d)
      '(a . (b . (c . d))))

(define x (list 'a 'b 'c))
(define y x)
(test y
      'y
      '(a b c))
(test (list? y)
      '(list? y)
      '#t)

(test (pair? '(a . b))
      '(pair? '(a . b))
      '#t)
(test (pair? '(a b c))
      '(pair? '(a b c))
      '#t)
(test (pair? '())
      '(pair? '())
      '#f)
(test (pair? '#(a b))
      '(pair? '#(a b))
      '#f)

(test (pair? '(a . 1))
      '(pair? '(a . 1))
      '#t)

(test (cons 'a '())
      '(cons 'a '())
      '(a))
(test (cons '(a) '(b c d))
      '(cons '(a) '(b c d))
      '((a) b c d))
(test (cons "a" '(b c))
      '(cons "a" '(b c))
      '("a" b c))
(test (cons 'a 3)
      '(cons 'a 3)
      '(a . 3))
(test (cons '(a b) 'c)
      '(cons '(a b) 'c)
      '((a b) . c))

(test (car '(a b c))
      '(car '(a b c))
      'a)
(test (car '((a) b c d))
      '(car '((a) b c d))
      '(a))
(test (car '(1 . 2))
      '(car '(1 . 2))
      '1)

(test (cdr '((a) b c d))
      '(cdr '((a) b c d))
      '(b c d))
(test (cdr '(1 . 2))
      '(cdr '(1 . 2))
      '2)

(define (f) (list 'not-a-constant-list))

(test (list? '(a b c))
      '(list? '(a b c))
      '#t)
(test (list? '())
      '(list? '())
      '#t)

(test (list 'a (+ 3 4) 'c)
      '(list 'a (+ 3 4) 'c)
      '(a 7 c))
(test (list)
      '(list)
      '())

(test (length '(a b c))
      '(length '(a b c))
      '3)
(test (length '(a (b) (c d e)))
      '(length '(a (b) (c d e)))
      '3)
(test (length '())
      '(length '())
      '0)

(test (append '(x) '(y))
      '(append '(x) '(y))
      '(x y))
(test (append '(a) '(b c d))
      '(append '(a) '(b c d))
      '(a b c d))
(test (append '(a (b)) '((c)))
      '(append '(a (b)) '((c)))
      '(a (b) (c)))
(test (append)
      '(append)
      '())
(test (append '(a b) '(c . d))
      '(append '(a b) '(c . d))
      '(a b c . d))
(test (append '() 'a)
      '(append '() 'a)
      'a)

(test (append '(a) '(b c) '(d) '(e f))
      '(append '(a) '(b c) '(d) '(e f))
      '(a b c d e f))
(test (append '(x y z))
      '(append '(x y z))
      '(x y z))
(test (eq? x (append x))
      '(eq? x (append x))
      '#t)

(test (reverse '(a b c))
      '(reverse '(a b c))
      '(c b a))
(test (reverse '(a (b c) d (e (f))))
      '(reverse '(a (b c) d (e (f))))
      '((e (f)) d (b c) a))

(test (list-ref '(a b c d) 2)
      '(list-ref '(a b c d) 2)
      'c)

(test (memq 'a '(a b c))
      '(memq 'a '(a b c))
      '(a b c))
(test (memq 'b '(a b c))
      '(memq 'b '(a b c))
      '(b c))
(test (memq 'a '(b c d))
      '(memq 'a '(b c d))
      '#f)
(test (memq (list 'a) '(b (a) c))
      '(memq (list 'a) '(b (a) c))
      '#f)
(test (member (list 'a) '(b (a) c))
      '(member (list 'a) '(b (a) c))
      '((a) c))
(test (memq 101 '(100 101 102))
      '(memq 101 '(100 101 102))
      'unspecified)
(test (memv 101 '(100 101 102))
      '(memv 101 '(100 101 102))
      '(101 102))

(define e '((a 1) (b 2) (c 3)))
(test (assq 'a e)
      '(assq 'a e)
      '(a 1))
(test (assq 'b e)
      '(assq 'b e)
      '(b 2))
(test (assq 'd e)
      '(assq 'd e)
      '#f)
(test (assq (list 'a) '(((a)) ((b)) ((c))))
      '(assq (list 'a) '(((a)) ((b)) ((c))))
      '#f)
(test (assoc (list 'a) '(((a)) ((b)) ((c))))
      '(assoc (list 'a) '(((a)) ((b)) ((c))))
      '((a)))
(test (assv 5 '((2 3) (5 7) (11 13)))
      '(assv 5 '((2 3) (5 7) (11 13)))
      '(5 7))

(SECTION 6 3 3) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test (symbol? 'foo)
      '(symbol? 'foo)
      '#t)
(test (symbol? (car '(a b)))
      '(symbol? (car '(a b)))
      '#t)
(test (symbol? "bar")
      '(symbol? "bar")
      '#f)
(test (symbol? 'nil)
      '(symbol? 'nil)
      '#t)
(test (symbol? '())
      '(symbol? '())
      '#f)
(test (symbol? #f)
      '(symbol? #f)
      '#f)

(test (symbol->string (string->symbol "Malvina"))
      '(symbol->string (string->symbol "Malvina"))
      '"Malvina")

(test (eq? 'mISSISSIppi 'mississippi)
      '(eq? 'mISSISSIppi 'mississippi)
      '#f)
(test (eq? 'bitBlt (string->symbol "bitBlt"))
      '(eq? 'bitBlt (string->symbol "bitBlt"))
      '#t)
(test (eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
      '(eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
      '#t)
(test (string=? "K. Harper, M.D."
                (symbol->string (string->symbol "K. Harper, M.D.")))
      '(string=? "K. Harper, M.D."
                 (symbol->string (string->symbol "K. Harper, M.D.")))
      '#t)

(test (string=? (symbol->string 'a) (symbol->string 'A))
      '(string=? (symbol->string 'a) (symbol->string 'A))
      '#f)
(test (not (or (string=? (symbol->string 'a) "A")
               (string=? (symbol->string 'A) "a")))
      '(not (or (string=? (symbol->string 'a) "A")
                (string=? (symbol->string 'A) "a")))
      '#t)



(SECTION 6 4) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(test (procedure? car)
      '(procedure? car)
      '#t)
(test (procedure? 'car)
      '(procedure? 'car)
      '#f)
(test (procedure? (lambda (x) (* x x)))
      '(procedure? (lambda (x) (* x x)))
      '#t)
(test (procedure? '(lambda (x) (* x x)))
      '(procedure? '(lambda (x) (* x x)))
      '#f)
(test (procedure? '())
      '(procedure? '())
      '#f)

(test (call-with-current-continuation procedure?)
      '(call-with-current-continuation procedure?)
      #t)
(test (procedure? call-with-current-continuation)
      '(procedure? call-with-current-continuation)
      #t)

(test (apply + (list 3 4))
      '(apply + (list 3 4))
      '7)
(define compose (lambda (f g) (lambda args (f (apply g args)))))
(test ((compose - *) 12 75)
      '((compose - *) 12 75)
      '-900)

(test (apply (lambda (a b) (+ a b)) (list 3 4))
      '(apply (lambda (a b) (+ a b)) (list 3 4))
      '7)
(test (apply + 10 (list 3 4))
      '(apply + 10 (list 3 4))
      '17)
(test (apply + 100 10 (list 3 4))
      '(apply + 100 10 (list 3 4))
      '117)
(test (apply list '())
      '(apply list '())
      '())

(test (map cadr '((a b) (d e) (g h)))
      '(map cadr '((a b) (d e) (g h)))
      '(b e h))
(test (map + '(1 2 3) '(4 5 6))
      '(map + '(1 2 3) '(4 5 6))
      '(5 7 9))

(test (not (member (let ((count 0))
                     (map (lambda (ignored)
                            (set! count (+ count 1))
                            count)
                          '(a b))) '((1 2) (2 1))))
      '(not (member (let ((count 0))
                      (map (lambda (ignored)
                             (set! count (+ count 1))
                             count)
                           '(a b))) '((1 2) (2 1))))
      '#f)

(test (let ((v (make-vector 5)))
        (for-each (lambda (i) (vector-set! v i (* i i)))
                  '(0 1 2 3 4))
        v)
      '(let ((v (make-vector 5)))
         (for-each (lambda (i) (vector-set! v i (* i i)))
                   '(0 1 2 3 4))
         v)
      '#(0 1 4 9 16))

;; force and delay
(test (force (delay (+ 1 2)))
      '(force (delay (+ 1 2)))
      3)
(test (let ((p (delay (+ 1 2))))
        (list (force p) (force p)))
      '(let ((p (delay (+ 1 2))))
         (list (force p) (force p)))
      '(3 3))

(define a-stream
  (letrec ((next (lambda (n) (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail (lambda (stream) (force (cdr stream))))
(test (head (tail (tail a-stream)))
      '(head (tail (tail a-stream)))
      2)

(define count 0)
(define p  (delay (begin (set! count (+ count 1))
                         (if (> count x)
                             count
                             (force p)))))
(define x 5)
(test (force p)
      '(force p)
      6)
(test (begin (set! x 10) (force p))
      '(begin (set! x 10) (force p))
      6)

(test (call-with-current-continuation
       (lambda (exit)
         (for-each (lambda (x) (if (negative? x) (exit x)))
                   '(54 0 37 -3 245 19))
         #t))
      '(call-with-current-continuation
        (lambda (exit)
          (for-each (lambda (x) (if (negative? x) (exit x)))
                    '(54 0 37 -3 245 19))
          #t))
      -3)

(define list-length
  (lambda (obj)
    (call-with-current-continuation
     (lambda (return)
       (letrec ((r (lambda (obj) (cond ((null? obj) 0)
                                       ((pair? obj) (+ (r (cdr obj)) 1))
                                       (else (return #f))))))
         (r obj))))))

(test (list-length '(1 2 3 4))
      '(list-length '(1 2 3 4))
      4)
(test (list-length '(a b . c))
      '(list-length '(a b . c))
      #f)
(test (map cadr '())
      '(map cadr '())
      '())

;;; This tests full conformance of call-with-current-continuation.  It
;;; is a separate test because some schemes do not support call/cc
;;; other than escape procedures.  I am indebted to
;;; raja@copper.ucs.indiana.edu (Raja Sooriamurthi) for fixing this
;;; code.  The function leaf-eq? compares the leaves of 2 arbitrary
;;; trees constructed of conses.  
(define (next-leaf-generator obj eot)
  (letrec ((return #f)
           (cont (lambda (x)
                   (recur obj)
                   (set! cont (lambda (x) (return eot)))
                   (cont #f)))
           (recur (lambda (obj)
                      (if (pair? obj)
                          (for-each recur obj)
                          (call-with-current-continuation
                           (lambda (c)
                             (set! cont c)
                             (return obj)))))))
    (lambda () (call-with-current-continuation
                (lambda (ret) (set! return ret) (cont #f))))))
(define (leaf-eq? x y)
  (let* ((eot (list 'eot))
         (xf (next-leaf-generator x eot))
         (yf (next-leaf-generator y eot)))
    (letrec ((loop (lambda (x y)
                     (cond ((not (eq? x y)) #f)
                           ((eq? eot x) #t)
                           (else (loop (xf) (yf)))))))
      (loop (xf) (yf)))))

(test (leaf-eq? '(a (b (c))) '((a) b c))
      '(leaf-eq? '(a (b (c))) '((a) b c))
      #t)
(test (leaf-eq? '(a (b (c))) '((a) b c d))
      '(leaf-eq? '(a (b (c))) '((a) b c d))
      #f)

(test (call-with-values (lambda () (values 4 5)) (lambda (a b) b))
      '(call-with-values (lambda () (values 4 5)) (lambda (a b) b))
      5)
(test (call-with-values * -)
      '(call-with-values * -)
      -1)

(test (let ((path '())
            (c #f))
        (let ((add (lambda (s) (set! path (cons s path)))))
          (dynamic-wind
              (lambda () (add 'connect))
              (lambda ()
                (add (call-with-current-continuation
                      (lambda (c0)
                        (set! c c0)
                        'talk1))))
              (lambda () (add 'disconnect)))
          (if (< (length path) 4)
              (c 'talk2)
              (reverse path))))
      '(let ((path '())) ...)
      '(connect talk1 disconnect 
                connect talk2 disconnect))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (main argv) (report-errors))
